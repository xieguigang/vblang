# Null propagating operator ?.

The `?.` operator is the second-highest voted request on UserVoice
http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/3990187-add-operator-to-c

We've discussed it in C# and VB Language Design Meeting. Mads has written up detailed notes [here](https://roslyn.codeplex.com/discussions/540281) and [here](https://roslyn.codeplex.com/discussions/540514). Some questions still remain, so I'm starting a thread for general discussion of this feature.

The core idea is to save you having to write code like this all the time, with null-checks:
``` cs
var temp = GetCustomer();
string name = (temp == null) ? null : temp.name;
```

Instead you'd write this:
``` cs
var temp = GetCustomer()?.name;
```

## How does ?. behave in sequences?

Q. How does it behave if you have several of these things in sequence? There are two possibilities on the table:
* *Left-associative*
* *Right-associative*



``` cs
class Customer1
{
    public readonly ExtraRef extraRef = new ExtraRef();
}

class ExtraRef
{
    public readonly string name = "fred";
}

Customer1 GetCustomer1()
{
    return (RND.Next() > 0.5) ? null : new Customer1();
}

int? len1a = GetCustomer1()?.extraRef?.name?.Length;
int? len1b = GetCustomer1()?.extraRef.name.Length;
```

What do you expect about `len1a` and `len1b`? [**edit** - initially I wrote the following out wrong. I've fixed them.]

* len1a - this is the same for both *left-associative* and *right-associative* -- it performs a null-check on GetCustomer1(), and if that succeeds, then it will perform null-check on extraRef and name.
* len1b - under *left-associative* it is a **compile-time error**. But under right-associative, it performs a null-check on GetCustomer1(), and then **skips** the null-check on extraRef and name.

Note: I constructed this example so that, if GetCustomer1() returns non-null, then I as the programmer know (from readonliness) that extraRef and name will both be non-null. The question is, is there some way to communicate this fact to the compiler, to avoid superfluous null-checks? **Left-associative says there isn't; right-associative says there is.**

(I benchmarked about a 5% perf overhead of doing those extra null-checks in the case where GetCustomer1() returns non-null)


``` cs
class  Customer2
{
    public readonly ExtraStruct extraStruct = new ExtraStruct {age=29};
}

struct ExtraStruct
{
    public int age;
}

Customer2 GetCustomer2()
{
    return (RND.Next() > 0.5) ? null : new Customer2();
}

int? age2a = GetCustomer2()?.extraStruct?.age;
int? age2b = GetCustomer2()?.extraStruct.age;
```

What do you expect about `age2a` and `age2b` ?

* age2a (how you must write it under *left-associative*) - this performs a null-check on GetCustomer2() and if this succeeds then, thanks to **compiler-optimization** and despite what's written, it knows it can skip the null-check on extraStruct.
* age2b (how you must write it under *right-associative*) - this performs a null-check on GetCustomer2() and if this succeeds then, **because of how you wrote it**, it skips the null-check on extraStruct.

Here, extraStruct is a structure and can never be null. So it doesn't make sense to null-check it. Should this fact be expressed as a compiler optimization in `age2a`? Or should it be expressed in syntax in `age2b`?


``` cs
var x = GetCustomer1()?.extraRef?.name?.Length
==>
var explainingVariable = GetCustomer1()?.extraRef;
var x = explainingVariable?.name?.Length;
```

* Is this a valid refactoring?
  * *left-associative* : it is a valid refactoring 
  * *right-associative* : it's an invalid refactoring
* How would you add parentheses to make the order explicit?
  * *left-associative* : `x = ((GetCustomer1()?.extraRef)?.name)?.Length`
  * *right-associative* : `x = GetCustomer1()?.(extraRef?.(name?.Length))`

You can see why we call them left-associative vs right-associative. It has to do with how you'd put parentheses into the expressions if you were writing them out explicitly.

Incidentally, there are other places where you can't just introduce an explaining variable. For instance, in `var y = a * b + c * d`, you can't just introduce an explaining variable for the first three parts `var ev = a * b + c; var y = ev * d;`. In this case though it's because of precedence, not because of associativity.

[NOTE: that &#43; is meant to be a PLUS sign. I don't know what's up with the markdown...]

Eric Lippert wrote a great blog on the associativity of the ?? operator: http://blog.coverity.com/2013/10/23/null-coalescing-bugs/#.Uzurzo1OV3Q


## Some other idioms with ?.

``` cs
// Call Dispose only if x is non-null:
x?.Dispose(); 


// Trigger an event only if it's non-null
// (not needed in VB, since this is already built into RaiseEvent statement)
event EventHandler OnFired;
void Fire()
{
    OnFired?.Invoke(this, new EventArgs());
}
```


## Codegen for ?.

I asked some CLR experts about what assembly code would be generated by the JIT for the ?. operator, and filled in some details from my hazy memory of OS architecture...

The question was, where does NullReferenceException currently get generated? When you do `GetCustomer1().extraRef`, and GetCustomer1() happens to return null, and so it fires a NullReferenceException, does that happen because the JIT implicitly generates a null-check?

No. The answer is that the NullReferenceException is generated at a lower level. More specifically, in between CPU and RAM there’s a chip called "Memory Management Unit (MMU) / Page Table". Every single time a thread accesses an address in the process’s virtual address-space, the MMU looks up the address in that page table to find where the address is in physical memory. If the virtual address isn’t yet mapped to a page of memory, then the MMU generates a page-fault which the OS has to handle, e.g. by paging in from disk. The CLR reserves addresses at the bottom of virtual address space but never actually pages them in. If ever an instruction tries to look up any address there, then the MMU generates a fault, and the CLR responds to it by generating a NullReferenceException.

The codegen for `x?.y` would probably be something like this...
```
mov rax, X
test rax, rax
beq :lbl
mov rax, [rax + k]
:lbl 
```

[Note: that &#43; is meant to be a PLUS sign. I don't know what's up with the markdown...]


